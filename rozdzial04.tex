\chapter{Implementacja}
\label{chap:implementacja}

\section{Struktura projektu}
\label{sec:struktura-projektu}

W tej sekcji przedstawiona zostanie logiczna i fizyczna struktura projektu. W szczególności zostanie uwzględniony podział na projekt aplikacji klienckiej oraz API, gdyż stanowią one tak na prawdę niezależne rozwiązania (ang.~\emph{solution}) w środowisku programistycznym Visual Studio 2019.

\subsection{Struktura fizyczna projektu}
\label{sec:struktura-fizyczna-projektu}

Obie aplikacje (API i aplikacja kliencka) znajdują się w tym samym repozytorium Git. Pliki ich rozwiązań znajdują się w folderze głównym repozytorium. W folderze tym znajduję się także plik \texttt{.gitignore}. Projekty należące do rozwiązań znajdują się w folderze \texttt{src}. W katalogu \texttt{Zoltaniecki.IDP} znajduję się potrzebny do testów dostawca tożsamości, będący tylko wydmuszką prawdziwego serwisu. Strukturę głównego folderu można zobaczyć na rysunku~\ref{fig:fiz-1}.

\begin{figure}[b]
	\centering
	\fbox{\includegraphics[width=.8\linewidth]{rys04/struktura-fizyczna-1.PNG}}
	\caption{Struktura fizyczna repozytorium}
	\label{fig:fiz-1}
\end{figure}

W folderze \texttt{src} znajdują się dwa następne foldery: \texttt{API} oraz \texttt{Client}. Znajdują się w nich kolejno projekty dla rozwiązania: \texttt{BudgetApplicationAPI.sln} i~dla rozwiązania \texttt{BudgetApplicationClient.sln} -- rysunek~\ref{fig:fiz-2}. 

%todo czy usunać?
\begin{figure}[t]
	\centering
	\fbox{\includegraphics[width=.7\linewidth]{rys04/struktura-fizyczna-2.PNG}}
	\caption{Zawartość folderu src}
	\label{fig:fiz-2}
\end{figure}

Warto zwrócić uwagę, że zarówno w API jak i w aplikacji klienckiej klasy pogrupowane są według funckjonoalności, a nie typów np.: \texttt{Services}, \texttt{Controllers}, \texttt{Views}, \texttt{Models}. Daje to dużą elastyczność i wygodę przy pracy programisty, gdyż nie musi szukać klas związanych z jedną funkcjonalnościach w wielu w poddrzewach katalogów.

\subsubsection{Fizyczna struktura API}

Aplikacja API składa się z czterech projektów: \texttt{BudgetApplication.API}, \texttt{BudgetApplication.Domain}, \texttt{BudgetApplication.Infrastructure} oraz \texttt{BudgetApplication.QueryInfrastructure}. Każdy z nich znajduje się w osobnym folderze -- rysunek~\ref{fig:fiz-api-1}.

%todo czy usunać?
\begin{figure}[t]
	\centering
	\fbox{\includegraphics[width=.7\linewidth]{rys04/struktura-fizyczna-api-1.PNG}}
	\caption{Zawartość folderu API}
	\label{fig:fiz-api-1}
\end{figure}

Na rysunku~\ref{fig:fiz-api-2} przedstawiono strukturę rozwiązania dla API. Widać na nim cztery projekty zawierające różne foldery. 

Foldery projektu \texttt{API} zawierają pogrupowane według funkcjonalności klasy kontrolerów API (ang.~\emph{controllers}), a także klasy związane z opisaną w sekcji~\ref{subsec:mediator} biblioteką \texttt{MediatR}: handlery (ang.~\emph{handlers}), komendy (ang.~\emph{commands}) i odpowiedzi(ang.~\emph{responses}). Katalog \texttt{Shared} zawiera współdzielone interfejsy. 

W projekcie \texttt{Domain} podkatalogi katalogu \texttt{AggregatesModel} zawierają pogrupowane według funkcjonalności encje, ich serwisy domenowe, klasy wyjątków domenowych, enumeratory, klasy typu \texttt{DTO} (ang.~\emph{Data transfer object}), a także inne klasy związane z przetwarzaniem logiki biznesowej. Folder \texttt{SeedWork} zawiera związane z taktycznym DDD interfejsy i klasy bazowe. \texttt{Program.cs} zawiera funkcję \texttt{Main}, czyli punkt wejścia do programu, a w klasie \texttt{Startup} konfigurowana jest aplikacja i jej serwisy.

Projekty \texttt{Infrastructure} i \texttt{QueryInfrastructure} zawierają warstwę dostępu do danych kolejno dla komend i zapytań, związanych z zastosowanym wzorcem \texttt{CQRS}, opisanym w punkcie~\ref{subsec:cqrs}. Foldery \texttt{EntityConfigurations} zawierają mapowania relacyjno-obiektowe charakterystyczne dla Entity Framework Core. Folder \texttt{Repositories} zawiera implementacje wzorca repozytorium dla klas encji biznesowych. Natomiast katalog \texttt{Migrations} zawiera pliki migracji modelu w bazie danych.

\begin{figure}[t]
	\centering
	\fbox{\includegraphics[width=.5\linewidth]{rys04/struktura-fizyczna-api-2.PNG}}
	\caption{Struktura rozwiązania API}
	\label{fig:fiz-api-2}
\end{figure}

\subsubsection{Fizyczna struktura aplikacji klienckiej}

Aplikacja kliencka składa się z dwóch projektów: \texttt{BudgetApplication.Client} oraz \texttt{BudgetApplication.Client.Core}, z których każdy jest w osobnym folderze -- rysunek~\ref{fig:fiz-client-1}. 

\begin{figure}[t]
	\centering
	\fbox{\includegraphics[width=.7\linewidth]{rys04/struktura-fizyczna-client-1.PNG}}
	\caption{Zawartość folderu Client}
	\label{fig:fiz-client-1}
\end{figure}

Strukturę rozwiązania aplikacji klienckiej przedstawiono na rysunku~\ref{fig:fiz-client-2}.

Pierwszy z projektów zawiera jeden główny folder z widokami i ich modelami strony (ang.~\emph{page model}) pogrupowanymi w foldery według funkcjonalności. W głównym folderze znajdują się też widoki niezwiązane z modelami strony, a także folder \texttt{Shared} z widokami częściowymi używanymi przez pozostałe widoki. Pliki: \texttt{Program.cs} i \texttt{Startup.cs} pełnią podobną funkcję co w projekcie API.

Drugi z projektów, także zawiera tylko jeden główny katalog. Zawiera on odpowiednio skonfigurowane klasy klientów HTTP, komunikujące się z API, a także klasy modeli, które są zwracane przez zakończone sukcesem żądania HTTP.

Klasa \texttt{ODataResult} jest klasą odpowiedzi żądań HTTP GET. Zawiera ona właściwości takie jak: \emph{Count}, \emph{Metadata}, \emph{Context} i \emph{Value}, ściśle związana z implementacją protokołu ODat -- punkt~\ref{subsec:odata}. Pole Value jest polem generycznym w zależności od zwracanego przez żądanie HTTP modelu. 

\begin{figure}[t]
	\centering
	\fbox{\includegraphics[width=.5\linewidth]{rys04/struktura-fizyczna-client-2.PNG}}
	\caption{Struktura rozwiązania aplikacji klienckiej}
	\label{fig:fiz-client-2}
\end{figure}

\subsection{Struktura logiczna projektu}
\label{sec:struktura-logiczna-projektu}

W tej sekcji zostanie zaprezentowana logiczna struktura projektu. 
Pokazane zostaną zależności między projektami zawartymi w rozwiązaniach dla aplikacji klienckiej oraz API.

\subsubsection{Logiczna struktura API}

Aplikacja API składa się z czterech projektów: \texttt{BudgetApplication.API}, \texttt{BudgetApplication.Domain}, \texttt{BudgetApplication.Infrastructure} oraz \texttt{BudgetApplication.QueryInfrastructure}.

Projekt \texttt{API} zawiera API kontrolery, a także handlery, odpowiedzi i żądania MediatR. Razem składają się one na warstwę aplikacji. Warstwa aplikacji operuje na obiektach domenowych, dlatego też projekt \texttt{API} zależny jest od projektu \texttt{Domain}.

Projekt \texttt{Domain} jest projektem ślepym i nie ma żadnych zależności. Znajduje się w nim kod niezależny od innych zewnętrznych frameworków. Definiuje on zachowania biznesowe obiektów domenowych, które są używane podczas wykonywania komend CQRS, wcześniej opisanych w punkcie~\ref{subsec:cqrs}. Model domenowy jest szczególnie istotny z punktu widzenia zachowania prawidłowego stanu systemu w trakcie i po wykonaniu operacji.

Warstwę persystencji dla encji domenowych stanowi projekt \texttt{Infrastructure}. Znajdują się w nim m.in. repozytoria, które implementują kontrakt zdefiniowany w projekcie \texttt{Domain}. Repozytoria korzystają mapera relacyjno-obiektowego Entity Framework Core. Ten projekt tworzony jest dla zachowania niezależności domeny od zewnętrznych frameworków.

Projekt \texttt{QueryInfrastructure} to projekt dostarczający uproszczoną wersję modelu zapisanego w bazie danych, bez logiki domenowej. Obiekty tworzone w tej części aplikacji potrzebne są dla wykonania zapytań CQRS -- punkt~\ref{subsec:cqrs}. Projekt stworzono, podobnie jak poprzedni, również z wykorzystaniem Entity Framework Core. Oba projekty są niezależne i nic nie stoi na przeszkodzie, aby zamiast EF Core wykorzystać technologię wbudowaną w Net Framework -- ADO.NET czy bibliotekę innego mapera relacyjno-obiektowego -- \texttt{Dapper}.

Wyżej opisane zależności przedstawiono na rysunku~\ref{fig:api-arch}. 

\begin{figure}[t]
	\centering
	\fbox{\includegraphics[width=.6\linewidth]{rys04/api-arch.png}}
	\caption{Zależności między projektami w API}
	\label{fig:api-arch}
\end{figure}

\subsubsection{Logiczna struktura aplikacji klienckiej}

Aplikacja kliencka składa się z dwóch projektów: \texttt{BudgetApplication.Client} oraz \texttt{BudgetApplication.Client.Core}. 

Projekt \texttt{Client} zawiera strony Razor Pages, które odpowiedzialne są za prezentowanie danych użytkownikowi i zapewnianie mu interfejsu do dokonywania zmian w systemie.

\texttt{Client.Core} zawiera klasy odpowiedzialne za komunikację z API i dostarczanie danych potrzebnych na stronach aplikacji.

Zależności projektów aplikacji klienckiej przedstawiono na rysunku~\ref{fig:client-arch}.

\begin{figure}[t]
	\centering
	\fbox{\includegraphics[width=.6\linewidth]{rys04/client-arch.png}}
	\caption{Zależności między projektami w aplikacji klienckiej}
	\label{fig:client-arch}
\end{figure}

\section{Szczegóły implementacji}
\label{sec:szczegoly-implementacji}



